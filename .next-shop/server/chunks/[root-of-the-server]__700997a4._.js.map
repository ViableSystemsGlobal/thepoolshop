{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/nanasasu/Desktop/adpoolsgroup/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///Users/nanasasu/Desktop/adpoolsgroup/src/lib/currency.ts"],"sourcesContent":["import { prisma } from \"./prisma\";\n\nexport interface CurrencyConversion {\n  fromCurrency: string;\n  toCurrency: string;\n  amount: number;\n  convertedAmount: number;\n  exchangeRate: number;\n  source: string;\n}\n\nexport interface ExchangeRateData {\n  fromCurrency: string;\n  toCurrency: string;\n  rate: number;\n  source: string;\n  effectiveFrom: Date;\n  effectiveTo?: Date;\n}\n\n/**\n * Get the latest exchange rate between two currencies\n */\nexport async function getExchangeRate(\n  fromCurrency: string,\n  toCurrency: string,\n  date?: Date\n): Promise<number | null> {\n  try {\n    if (fromCurrency === toCurrency) return 1;\n\n    const effectiveDate = date || new Date();\n\n    // First, try to find direct rate\n    let exchangeRate = await prisma.exchangeRate.findFirst({\n      where: {\n        fromCurrency,\n        toCurrency,\n        isActive: true,\n        effectiveFrom: { lte: effectiveDate },\n        OR: [\n          { effectiveTo: null },\n          { effectiveTo: { gte: effectiveDate } }\n        ]\n      },\n      orderBy: { effectiveFrom: 'desc' }\n    });\n\n    // If no direct rate found, try reverse rate (inverse calculation)\n    if (!exchangeRate) {\n      const reverseRate = await prisma.exchangeRate.findFirst({\n        where: {\n          fromCurrency: toCurrency,\n          toCurrency: fromCurrency,\n          isActive: true,\n          effectiveFrom: { lte: effectiveDate },\n          OR: [\n            { effectiveTo: null },\n            { effectiveTo: { gte: effectiveDate } }\n          ]\n        },\n        orderBy: { effectiveFrom: 'desc' }\n      });\n\n      if (reverseRate && reverseRate.rate) {\n        // Calculate inverse rate\n        const inverseRate = 1 / Number(reverseRate.rate);\n        return Math.round(inverseRate * 10000) / 10000; // Round to 4 decimal places\n      }\n    }\n\n    return exchangeRate ? Number(exchangeRate.rate) : null;\n  } catch (error) {\n    console.error('Error fetching exchange rate:', error);\n    return null;\n  }\n}\n\n/**\n * Convert amount from one currency to another\n */\nexport async function convertCurrency(\n  fromCurrency: string,\n  toCurrency: string,\n  amount: number,\n  date?: Date\n): Promise<CurrencyConversion | null> {\n  try {\n    if (fromCurrency === toCurrency) {\n      return {\n        fromCurrency,\n        toCurrency,\n        amount,\n        convertedAmount: amount,\n        exchangeRate: 1,\n        source: 'same_currency'\n      };\n    }\n\n    const exchangeRate = await getExchangeRate(fromCurrency, toCurrency, date);\n    \n    if (!exchangeRate) {\n      throw new Error(`No exchange rate found for ${fromCurrency} to ${toCurrency}`);\n    }\n\n    const convertedAmount = amount * exchangeRate;\n\n    return {\n      fromCurrency,\n      toCurrency,\n      amount,\n      convertedAmount: Math.round(convertedAmount * 100) / 100, // Round to 2 decimal places\n      exchangeRate,\n      source: 'database'\n    };\n  } catch (error) {\n    console.error('Error converting currency:', error);\n    return null;\n  }\n}\n\n/**\n * Update exchange rate manually\n */\nexport async function updateExchangeRate(\n  fromCurrency: string,\n  toCurrency: string,\n  rate: number,\n  source: string = 'manual',\n  effectiveFrom?: Date,\n  effectiveTo?: Date\n): Promise<boolean> {\n  try {\n    await prisma.exchangeRate.create({\n      data: {\n        fromCurrency,\n        toCurrency,\n        rate,\n        source,\n        effectiveFrom: effectiveFrom || new Date(),\n        effectiveTo\n      }\n    });\n\n    return true;\n  } catch (error) {\n    console.error('Error updating exchange rate:', error);\n    return false;\n  }\n}\n\n/**\n * Get all supported currencies\n */\nexport async function getSupportedCurrencies() {\n  try {\n    return await prisma.currency.findMany({\n      where: { isActive: true },\n      orderBy: { code: 'asc' }\n    });\n  } catch (error) {\n    console.error('Error fetching currencies:', error);\n    return [];\n  }\n}\n\n/**\n * Format currency amount with proper symbol and formatting\n */\nexport function formatCurrency(\n  amount: number,\n  currencyCode: string,\n  currencySymbol?: string\n): string {\n  const symbol = currencySymbol || getCurrencySymbol(currencyCode);\n  \n  // Format number with proper decimal places\n  const formattedAmount = new Intl.NumberFormat('en-US', {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format(amount);\n\n  return `${symbol}${formattedAmount}`;\n}\n\n/**\n * Get currency symbol by code\n */\nexport function getCurrencySymbol(currencyCode: string): string {\n  const symbols: Record<string, string> = {\n    'USD': '$',\n    'GHS': 'GH₵',\n    'EUR': '€',\n    'GBP': '£',\n    'NGN': '₦',\n    'KES': 'KSh',\n    'ZAR': 'R',\n    'EGP': 'E£',\n    'MAD': 'MAD',\n    'TND': 'DT'\n  };\n\n  return symbols[currencyCode] || currencyCode;\n}\n\n/**\n * Calculate product price in different currencies\n */\nexport async function calculateProductPrice(\n  productId: string,\n  targetCurrency: string,\n  date?: Date\n): Promise<{\n  basePrice: number;\n  baseCurrency: string;\n  convertedPrice: number;\n  targetCurrency: string;\n  exchangeRate: number;\n} | null> {\n  try {\n    const product = await prisma.product.findUnique({\n      where: { id: productId }\n    });\n\n    if (!product || !product.price) {\n      return null;\n    }\n\n    const basePrice = Number(product.price);\n    const baseCurrency = product.importCurrency;\n\n    if (baseCurrency === targetCurrency) {\n      return {\n        basePrice,\n        baseCurrency,\n        convertedPrice: basePrice,\n        targetCurrency,\n        exchangeRate: 1\n      };\n    }\n\n    const conversion = await convertCurrency(\n      baseCurrency,\n      targetCurrency,\n      basePrice,\n      date\n    );\n\n    if (!conversion) {\n      return null;\n    }\n\n    return {\n      basePrice,\n      baseCurrency,\n      convertedPrice: conversion.convertedAmount,\n      targetCurrency,\n      exchangeRate: conversion.exchangeRate\n    };\n  } catch (error) {\n    console.error('Error calculating product price:', error);\n    return null;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///Users/nanasasu/Desktop/adpoolsgroup/src/app/api/public/shop/orders/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { prisma } from \"@/lib/prisma\";\nimport { cookies } from \"next/headers\";\nimport { verify } from \"jsonwebtoken\";\nimport { convertCurrency } from \"@/lib/currency\";\n\nconst JWT_SECRET = process.env.NEXTAUTH_SECRET || \"adpools-secret-key-2024-production-change-me\";\n\n// GET /api/public/shop/orders - Get customer orders\nexport async function GET(request: NextRequest) {\n  try {\n    // Get customer token from cookies\n    const cookieStore = await cookies();\n    const token = cookieStore.get(\"customer_token\")?.value;\n\n    if (!token) {\n      return NextResponse.json(\n        { error: \"Authentication required\" },\n        { status: 401 }\n      );\n    }\n\n    // Verify token\n    let decoded: any;\n    try {\n      decoded = verify(token, JWT_SECRET);\n    } catch (error) {\n      console.error(\"Token verification failed:\", error);\n      return NextResponse.json(\n        { error: \"Invalid token\" },\n        { status: 401 }\n      );\n    }\n\n    if (decoded.type !== \"customer\") {\n      return NextResponse.json(\n        { error: \"Invalid token type\" },\n        { status: 401 }\n      );\n    }\n\n    // Get customer from database\n    const customer = await prisma.customer.findUnique({\n      where: { id: decoded.id },\n      select: {\n        id: true,\n        email: true,\n        firstName: true,\n        lastName: true,\n        phone: true,\n      },\n    });\n\n    if (!customer) {\n      console.error(\"Customer not found for ID:\", decoded.id);\n      return NextResponse.json(\n        { error: \"Customer not found\" },\n        { status: 404 }\n      );\n    }\n\n    console.log(\"Fetching orders for customer:\", customer.email);\n\n    // Get search params\n    const { searchParams } = new URL(request.url);\n    const page = parseInt(searchParams.get(\"page\") || \"1\");\n    const limit = parseInt(searchParams.get(\"limit\") || \"10\");\n    const status = searchParams.get(\"status\");\n\n    // Build where clause\n    const where: any = {\n      lead: {\n        email: customer.email,\n      },\n    };\n\n    if (status && status !== \"all\") {\n      where.status = status;\n    }\n\n    // Fetch invoices (orders) for this customer\n    console.log(\"Querying invoices with where clause:\", JSON.stringify(where, null, 2));\n    const invoices = await prisma.invoice.findMany({\n      where,\n      include: {\n        quotation: {\n          include: {\n            lines: {\n              include: {\n                product: true,\n              },\n            },\n          },\n        },\n        lines: {\n          include: {\n            product: true,\n          },\n        },\n        lead: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            company: true,\n          },\n        },\n      },\n      orderBy: {\n        createdAt: \"desc\",\n      },\n      skip: (page - 1) * limit,\n      take: limit,\n    });\n    \n    console.log(`Found ${invoices.length} invoices for customer`);\n\n    // Get total count\n    const total = await prisma.invoice.count({ where });\n\n    // Transform invoices to orders format\n    const orders = await Promise.all(invoices.map(async (invoice) => {\n      const invoiceCurrency = invoice.currency || \"GHS\";\n      \n      // Parse images for products and convert prices\n      const items = await Promise.all((invoice.lines || []).map(async (line) => {\n        let images = [];\n        if (line.product?.images) {\n          try {\n            images = JSON.parse(line.product.images);\n          } catch {\n            images = [line.product.images];\n          }\n        }\n\n        // Convert unit price to GHS\n        // Check product's base currency first, then fall back to invoice currency\n        let unitPriceInGHS = line.unitPrice || 0;\n        const productBaseCurrency = line.product?.baseCurrency || invoiceCurrency;\n        const sourceCurrency = productBaseCurrency || invoiceCurrency || \"GHS\";\n        \n        if (sourceCurrency !== \"GHS\" && line.unitPrice) {\n          const priceConversion = await convertCurrency(sourceCurrency, \"GHS\", line.unitPrice);\n          if (priceConversion) {\n            unitPriceInGHS = priceConversion.convertedAmount;\n          } else {\n            console.warn(`Failed to convert unit price from ${sourceCurrency} to GHS for product ${line.productId}`);\n          }\n        }\n\n        // Convert discount using same currency as unit price\n        let discountInGHS = line.discount || 0;\n        if (sourceCurrency !== \"GHS\" && line.discount) {\n          const discountConversion = await convertCurrency(sourceCurrency, \"GHS\", line.discount);\n          if (discountConversion) {\n            discountInGHS = discountConversion.convertedAmount;\n          }\n        }\n\n        // Calculate line total in GHS\n        const lineTotalInGHS = (unitPriceInGHS * line.quantity) - discountInGHS;\n\n        return {\n          id: line.id,\n          productId: line.productId,\n          productName: line.product?.name || \"Product\",\n          productSku: line.product?.sku || \"\",\n          quantity: line.quantity,\n          unitPrice: unitPriceInGHS,\n          discount: discountInGHS,\n          lineTotal: lineTotalInGHS,\n          image: images[0] || null,\n        };\n      }));\n\n      // Determine order status\n      let orderStatus = \"PENDING\";\n      if (invoice.status === \"PAID\" || invoice.paymentStatus === \"PAID\") {\n        orderStatus = \"COMPLETED\";\n      } else if (invoice.status === \"SENT\") {\n        orderStatus = \"PROCESSING\";\n      } else if (invoice.status === \"CANCELLED\") {\n        orderStatus = \"CANCELLED\";\n      }\n\n      // Recalculate totals from converted line items (more accurate than converting invoice totals)\n      const recalculatedSubtotal = items.reduce((sum, item) => sum + item.lineTotal, 0);\n      const recalculatedTax = recalculatedSubtotal * 0.125; // 12.5% VAT\n      const recalculatedTotal = recalculatedSubtotal + recalculatedTax;\n      \n      // Use recalculated totals from converted line items (more accurate)\n      let subtotalInGHS = recalculatedSubtotal;\n      let taxInGHS = recalculatedTax;\n      let discountInGHS = invoice.discount || 0;\n      let totalInGHS = recalculatedTotal;\n      let amountPaidInGHS = invoice.amountPaid || 0;\n      let amountDueInGHS = invoice.amountDue || 0;\n\n      // Convert payment-related amounts if invoice currency is not GHS\n      if (invoiceCurrency !== \"GHS\") {\n        if (invoice.discount) {\n          const discountConversion = await convertCurrency(invoiceCurrency, \"GHS\", invoice.discount);\n          if (discountConversion) {\n            discountInGHS = discountConversion.convertedAmount;\n          }\n        }\n        if (invoice.amountPaid) {\n          const amountPaidConversion = await convertCurrency(invoiceCurrency, \"GHS\", invoice.amountPaid);\n          if (amountPaidConversion) {\n            amountPaidInGHS = amountPaidConversion.convertedAmount;\n          }\n        }\n        if (invoice.amountDue) {\n          const amountDueConversion = await convertCurrency(invoiceCurrency, \"GHS\", invoice.amountDue);\n          if (amountDueConversion) {\n            amountDueInGHS = amountDueConversion.convertedAmount;\n          }\n        }\n      }\n\n      // Parse addresses\n      let shippingAddress = null;\n      let billingAddress = null;\n      \n      try {\n        if (invoice.shippingAddressSnapshot) {\n          shippingAddress = typeof invoice.shippingAddressSnapshot === 'string' \n            ? JSON.parse(invoice.shippingAddressSnapshot)\n            : invoice.shippingAddressSnapshot;\n        }\n        if (invoice.billingAddressSnapshot) {\n          billingAddress = typeof invoice.billingAddressSnapshot === 'string'\n            ? JSON.parse(invoice.billingAddressSnapshot) \n            : invoice.billingAddressSnapshot;\n        }\n      } catch (e) {\n        console.error(\"Error parsing addresses:\", e);\n      }\n\n      return {\n        id: invoice.id,\n        orderNumber: invoice.number,\n        quotationNumber: invoice.quotation?.number,\n        status: orderStatus,\n        paymentStatus: invoice.paymentStatus,\n        paymentMethod: invoice.paymentTerms || \"CASH\",\n        orderDate: invoice.issueDate || invoice.createdAt,\n        dueDate: invoice.dueDate,\n        currency: \"GHS\", // Always return in GHS\n        subtotal: subtotalInGHS,\n        tax: taxInGHS,\n        discount: discountInGHS,\n        total: totalInGHS,\n        amountPaid: amountPaidInGHS,\n        amountDue: amountDueInGHS,\n        items: items,\n        itemCount: items.length,\n        customer: {\n          name: `${invoice.lead?.firstName || \"\"} ${invoice.lead?.lastName || \"\"}`.trim() || invoice.lead?.email,\n          email: invoice.lead?.email,\n          phone: invoice.lead?.phone,\n          company: invoice.lead?.company,\n        },\n        shippingAddress,\n        billingAddress,\n        notes: invoice.notes,\n      };\n    }));\n\n    return NextResponse.json({\n      orders,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit),\n      },\n    });\n  } catch (error) {\n    console.error(\"Error fetching orders:\", error);\n    console.error(\"Error details:\", error instanceof Error ? error.stack : String(error));\n    return NextResponse.json(\n      { \n        error: \"Failed to fetch orders\",\n        details: process.env.NODE_ENV === \"development\" ? (error instanceof Error ? error.message : String(error)) : undefined\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// GET order by ID (via POST for body support)\nexport async function POST(request: NextRequest) {\n  try {\n    // Get customer token from cookies\n    const cookieStore = await cookies();\n    const token = cookieStore.get(\"customer_token\")?.value;\n\n    if (!token) {\n      return NextResponse.json(\n        { error: \"Authentication required\" },\n        { status: 401 }\n      );\n    }\n\n    // Verify token\n    let decoded: any;\n    try {\n      decoded = verify(token, JWT_SECRET);\n    } catch (error) {\n      console.error(\"Token verification failed:\", error);\n      return NextResponse.json(\n        { error: \"Invalid token\" },\n        { status: 401 }\n      );\n    }\n\n    if (decoded.type !== \"customer\") {\n      return NextResponse.json(\n        { error: \"Invalid token type\" },\n        { status: 401 }\n      );\n    }\n\n    // Get order ID from body\n    const body = await request.json();\n    const { orderId } = body;\n\n    if (!orderId) {\n      return NextResponse.json(\n        { error: \"Order ID is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Fetch invoice (order) with customer validation\n    const invoice = await prisma.invoice.findFirst({\n      where: {\n        id: orderId,\n        lead: {\n          email: decoded.email,\n        },\n      },\n      include: {\n        quotation: {\n          include: {\n            lines: {\n              include: {\n                product: true,\n              },\n            },\n          },\n        },\n        lines: {\n          include: {\n            product: true,\n          },\n        },\n        lead: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            company: true,\n            billingAddress: true,\n            shippingAddress: true,\n          },\n        },\n        payments: {\n          orderBy: {\n            createdAt: \"desc\",\n          },\n        },\n      },\n    });\n\n    if (!invoice) {\n      return NextResponse.json(\n        { error: \"Order not found\" },\n        { status: 404 }\n      );\n    }\n\n    // Transform invoice to detailed order format\n    const invoiceCurrency = invoice.currency || \"GHS\";\n    const items = await Promise.all((invoice.lines || []).map(async (line) => {\n      let images = [];\n      if (line.product?.images) {\n        try {\n          images = JSON.parse(line.product.images);\n        } catch {\n          images = [line.product.images];\n        }\n      }\n\n      let attributes = {};\n      if (line.product?.attributes) {\n        try {\n          attributes = JSON.parse(line.product.attributes as string);\n        } catch {\n          attributes = {};\n        }\n      }\n\n      // Convert unit price to GHS\n      // Check product's base currency first, then fall back to invoice currency\n      let unitPriceInGHS = line.unitPrice || 0;\n      const productBaseCurrency = line.product?.baseCurrency || invoiceCurrency;\n      const sourceCurrency = productBaseCurrency || invoiceCurrency || \"GHS\";\n      \n      if (sourceCurrency !== \"GHS\" && line.unitPrice) {\n        const priceConversion = await convertCurrency(sourceCurrency, \"GHS\", line.unitPrice);\n        if (priceConversion) {\n          unitPriceInGHS = priceConversion.convertedAmount;\n        } else {\n          console.warn(`Failed to convert unit price from ${sourceCurrency} to GHS for product ${line.productId}`);\n        }\n      }\n\n      // Convert discount using same currency as unit price\n      let discountInGHS = line.discount || 0;\n      if (sourceCurrency !== \"GHS\" && line.discount) {\n        const discountConversion = await convertCurrency(sourceCurrency, \"GHS\", line.discount);\n        if (discountConversion) {\n          discountInGHS = discountConversion.convertedAmount;\n        }\n      }\n\n      // Calculate line total in GHS\n      const lineTotalInGHS = (unitPriceInGHS * line.quantity) - discountInGHS;\n\n      return {\n        id: line.id,\n        productId: line.productId,\n        productName: line.product?.name || \"Product\",\n        productDescription: line.product?.description,\n        productSku: line.product?.sku || \"\",\n        quantity: line.quantity,\n        unitPrice: unitPriceInGHS,\n        discount: discountInGHS,\n        lineTotal: lineTotalInGHS,\n        images: images,\n        attributes: attributes,\n      };\n    }));\n\n    // Determine order status\n    let orderStatus = \"PENDING\";\n    if (invoice.status === \"PAID\" || invoice.paymentStatus === \"PAID\") {\n      orderStatus = \"COMPLETED\";\n    } else if (invoice.status === \"SENT\") {\n      orderStatus = \"PROCESSING\";\n    } else if (invoice.status === \"CANCELLED\") {\n      orderStatus = \"CANCELLED\";\n    }\n\n    // Recalculate totals from converted line items (more accurate than converting invoice totals)\n    const recalculatedSubtotal = items.reduce((sum, item) => sum + item.lineTotal, 0);\n    const recalculatedTax = recalculatedSubtotal * 0.125; // 12.5% VAT\n    const recalculatedTotal = recalculatedSubtotal + recalculatedTax;\n    \n    // Use recalculated totals from converted line items (more accurate)\n    let subtotalInGHS = recalculatedSubtotal;\n    let taxInGHS = recalculatedTax;\n    let discountInGHS = invoice.discount || 0;\n    let totalInGHS = recalculatedTotal;\n    let amountPaidInGHS = invoice.amountPaid || 0;\n    let amountDueInGHS = invoice.amountDue || 0;\n\n    // Convert payment-related amounts if invoice currency is not GHS\n    if (invoiceCurrency !== \"GHS\") {\n        if (invoice.discount) {\n          const discountConversion = await convertCurrency(invoiceCurrency, \"GHS\", invoice.discount);\n          if (discountConversion) {\n            discountInGHS = discountConversion.convertedAmount;\n          }\n        }\n        if (invoice.amountPaid) {\n          const amountPaidConversion = await convertCurrency(invoiceCurrency, \"GHS\", invoice.amountPaid);\n          if (amountPaidConversion) {\n            amountPaidInGHS = amountPaidConversion.convertedAmount;\n          }\n        }\n        if (invoice.amountDue) {\n          const amountDueConversion = await convertCurrency(invoiceCurrency, \"GHS\", invoice.amountDue);\n          if (amountDueConversion) {\n            amountDueInGHS = amountDueConversion.convertedAmount;\n          }\n        }\n      }\n\n      // Convert payment amounts\n      const paymentsInGHS = await Promise.all((invoice.payments || []).map(async (payment) => {\n        let amountInGHS = payment.amount || 0;\n        if (invoiceCurrency !== \"GHS\" && payment.amount) {\n          const paymentConversion = await convertCurrency(invoiceCurrency, \"GHS\", payment.amount);\n          if (paymentConversion) {\n            amountInGHS = paymentConversion.convertedAmount;\n          }\n        }\n        return {\n          id: payment.id,\n          amount: amountInGHS,\n          method: payment.method,\n          reference: payment.reference,\n          date: payment.createdAt,\n          notes: payment.notes,\n        };\n      }));\n\n      // Parse addresses\n      let shippingAddress = null;\n      let billingAddress = null;\n      \n      try {\n        if (invoice.shippingAddressSnapshot) {\n          shippingAddress = typeof invoice.shippingAddressSnapshot === 'string' \n            ? JSON.parse(invoice.shippingAddressSnapshot)\n            : invoice.shippingAddressSnapshot;\n        }\n        if (invoice.billingAddressSnapshot) {\n          billingAddress = typeof invoice.billingAddressSnapshot === 'string'\n            ? JSON.parse(invoice.billingAddressSnapshot) \n            : invoice.billingAddressSnapshot;\n        }\n      } catch (e) {\n        console.error(\"Error parsing addresses:\", e);\n      }\n\n      const order = {\n        id: invoice.id,\n        orderNumber: invoice.number,\n        quotationNumber: invoice.quotation?.number,\n        status: orderStatus,\n        paymentStatus: invoice.paymentStatus,\n        paymentMethod: invoice.paymentTerms || \"CASH\",\n        orderDate: invoice.issueDate || invoice.createdAt,\n        dueDate: invoice.dueDate,\n        currency: \"GHS\", // Always return in GHS\n        subtotal: subtotalInGHS,\n        tax: taxInGHS,\n        discount: discountInGHS,\n        total: totalInGHS,\n        amountPaid: amountPaidInGHS,\n        amountDue: amountDueInGHS,\n      items: items,\n      itemCount: items.length,\n      customer: {\n        name: `${invoice.lead?.firstName || \"\"} ${invoice.lead?.lastName || \"\"}`.trim() || invoice.lead?.email,\n        email: invoice.lead?.email,\n        phone: invoice.lead?.phone,\n        company: invoice.lead?.company,\n      },\n        shippingAddress,\n        billingAddress,\n        notes: invoice.notes,\n        payments: paymentsInGHS,\n      timeline: [\n        {\n          status: \"ORDER_PLACED\",\n          date: invoice.createdAt,\n          description: \"Order was placed\",\n        },\n        ...(invoice.status === \"SENT\" || invoice.status === \"PAID\" ? [{\n          status: \"PROCESSING\",\n          date: invoice.issueDate || invoice.createdAt,\n          description: \"Order is being processed\",\n        }] : []),\n        ...(invoice.paymentStatus === \"PAID\" ? [{\n          status: \"PAYMENT_RECEIVED\",\n          date: invoice.payments[0]?.createdAt || invoice.updatedAt,\n          description: \"Payment has been received\",\n        }] : []),\n        ...(invoice.status === \"PAID\" ? [{\n          status: \"COMPLETED\",\n          date: invoice.updatedAt,\n          description: \"Order has been completed\",\n        }] : []),\n      ],\n    };\n\n    return NextResponse.json(order);\n  } catch (error) {\n    console.error(\"Error fetching order details:\", error);\n    return NextResponse.json(\n      { error: \"Failed to fetch order details\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}